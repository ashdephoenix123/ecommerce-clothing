import formidable from "formidable";
import fs from "fs";
import csv from "csv-parser";
import connectDB from "@/middleware/conn";
import Commodity from "@/models/Commodity";

export const config = {
  api: {
    bodyParser: false,
  },
};

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  await connectDB();

  const form = formidable({ multiples: false, keepExtensions: true });

  form.parse(req, async (err, fields, files) => {
    if (err) {
      return res.status(500).json({ error: "File parsing failed" });
    }

    try {
      const file = Array.isArray(files.csvFile)
        ? files.csvFile[0]
        : files.csvFile;

      if (!file || !file.filepath) {
        return res.status(400).json({ error: "No file uploaded" });
      }

      const results = [];
      await new Promise((resolve, reject) => {
        fs.createReadStream(file.filepath)
          .pipe(csv())
          .on("data", (row) => results.push(row))
          .on("end", resolve)
          .on("error", reject);
      });

      // --- START: MODIFIED TRANSFORMATION LOGIC ---

      // ðŸ”¹ Use a Map to group variants by product name.
      // This transforms the "one row per variant" CSV format
      // back into your schema's "one product with an array of variants" format.
      const productsMap = new Map();

      // Helper to convert empty CSV strings "" to null, which Mongoose prefers
      const toNull = (val) => (val === "" || val === undefined ? null : val);

      // Helper to split pipe-delimited arrays (e.g., "M|L" or "url1|url2")
      const splitPipeArray = (str) => {
        if (!str) return [];
        return str
          .split("|")
          .map((s) => s.trim())
          .filter(Boolean); // filter(Boolean) removes empty strings
      };

      for (const row of results) {
        // If 'name' is missing, we can't group, so skip.
        if (!row.name) continue;

        // If this is the first time seeing this product, create its main object.
        if (!productsMap.has(row.name)) {
          const product = {
            // Your pre('validate') hook will use this SKU or generate one if null
            sku: toNull(row.sku),
            name: row.name,
            description: row.description,
            brand: toNull(row.brand), // Add brand
            category: {
              // Use bracket notation for headers with '.'
              main: toNull(row["category.main"]),
              sub: toNull(row["category.sub"]),
              third: toNull(row["category.third"]),
            },
            variants: [], // Initialize variants array
            // 'slug' will be auto-generated by your pre('validate') hook
          };
          productsMap.set(row.name, product);
        }

        // --- Process and add the variant from the current row ---
        const variant = {
          size: splitPipeArray(row["variant.size"]),
          images: splitPipeArray(row["variant.images"]),
          color: toNull(row["variant.color"]),
          stock: parseInt(row["variant.stock"]) || 0,
          price: parseFloat(row["variant.price"]) || 0,
        };

        // Add this variant to its product's variant array
        productsMap.get(row.name).variants.push(variant);
      }

      // ðŸ”¹ Get the final array of documents from the Map
      const docs = Array.from(productsMap.values());

      // --- END: MODIFIED TRANSFORMATION LOGIC ---

      if (docs.length > 0) {
        // Use Model.create() to trigger Mongoose hooks (for slug/sku)
        const createdCommodities = await Commodity.create(docs);
        res.status(200).json({
          inserted: createdCommodities.length,
          productNames: createdCommodities.map((p) => p.name),
        });
      } else {
        res.status(200).json({ inserted: 0 });
      }
    } catch (e) {
      console.error("Upload error:", e);
      // Catch duplicate key errors or other validation errors
      if (e.code === 11000) {
        return res.status(400).json({
          error: "One or more SKUs or names in the CSV already exist.",
          details: e.message,
        });
      }
      res.status(500).json({ error: e.message });
    }
  });
}
